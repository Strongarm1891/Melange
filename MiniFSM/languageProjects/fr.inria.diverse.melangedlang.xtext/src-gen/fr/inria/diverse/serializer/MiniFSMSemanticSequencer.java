/*
 * generated by Xtext 2.9.2
 */
package fr.inria.diverse.serializer;

import com.google.inject.Inject;
import fr.inria.diverse.melanger.melangedlang.minifsm.And;
import fr.inria.diverse.melanger.melangedlang.minifsm.Block;
import fr.inria.diverse.melanger.melangedlang.minifsm.BooleanAssignment;
import fr.inria.diverse.melanger.melangedlang.minifsm.BooleanVar;
import fr.inria.diverse.melanger.melangedlang.minifsm.BooleanVariableRef;
import fr.inria.diverse.melanger.melangedlang.minifsm.Context;
import fr.inria.diverse.melanger.melangedlang.minifsm.Divide;
import fr.inria.diverse.melanger.melangedlang.minifsm.Equal;
import fr.inria.diverse.melanger.melangedlang.minifsm.FSM;
import fr.inria.diverse.melanger.melangedlang.minifsm.FinalState;
import fr.inria.diverse.melanger.melangedlang.minifsm.Greater;
import fr.inria.diverse.melanger.melangedlang.minifsm.GreaterOrEqual;
import fr.inria.diverse.melanger.melangedlang.minifsm.IntAssignment;
import fr.inria.diverse.melanger.melangedlang.minifsm.IntVariableRef;
import fr.inria.diverse.melanger.melangedlang.minifsm.IntegerVar;
import fr.inria.diverse.melanger.melangedlang.minifsm.Less;
import fr.inria.diverse.melanger.melangedlang.minifsm.LessOrEqual;
import fr.inria.diverse.melanger.melangedlang.minifsm.MinifsmPackage;
import fr.inria.diverse.melanger.melangedlang.minifsm.Minus;
import fr.inria.diverse.melanger.melangedlang.minifsm.Multiply;
import fr.inria.diverse.melanger.melangedlang.minifsm.Not;
import fr.inria.diverse.melanger.melangedlang.minifsm.Or;
import fr.inria.diverse.melanger.melangedlang.minifsm.Plus;
import fr.inria.diverse.melanger.melangedlang.minifsm.PrintStr;
import fr.inria.diverse.melanger.melangedlang.minifsm.PrintVar;
import fr.inria.diverse.melanger.melangedlang.minifsm.State;
import fr.inria.diverse.melanger.melangedlang.minifsm.Transition;
import fr.inria.diverse.services.MiniFSMGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MiniFSMSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MiniFSMGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MinifsmPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MinifsmPackage.AND:
				sequence_AndOr(context, (And) semanticObject); 
				return; 
			case MinifsmPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case MinifsmPackage.BOOLEAN:
				sequence_Boolean(context, (fr.inria.diverse.melanger.melangedlang.minifsm.Boolean) semanticObject); 
				return; 
			case MinifsmPackage.BOOLEAN_ASSIGNMENT:
				sequence_BooleanAssignment(context, (BooleanAssignment) semanticObject); 
				return; 
			case MinifsmPackage.BOOLEAN_VAR:
				sequence_BooleanVar(context, (BooleanVar) semanticObject); 
				return; 
			case MinifsmPackage.BOOLEAN_VARIABLE_REF:
				sequence_BooleanVariableRef(context, (BooleanVariableRef) semanticObject); 
				return; 
			case MinifsmPackage.CONTEXT:
				sequence_Context(context, (Context) semanticObject); 
				return; 
			case MinifsmPackage.DIVIDE:
				sequence_MultDiv(context, (Divide) semanticObject); 
				return; 
			case MinifsmPackage.EQUAL:
				sequence_Equal(context, (Equal) semanticObject); 
				return; 
			case MinifsmPackage.FSM:
				sequence_FSM(context, (FSM) semanticObject); 
				return; 
			case MinifsmPackage.FINAL_STATE:
				sequence_FinalState(context, (FinalState) semanticObject); 
				return; 
			case MinifsmPackage.GREATER:
				sequence_Greater(context, (Greater) semanticObject); 
				return; 
			case MinifsmPackage.GREATER_OR_EQUAL:
				sequence_GreaterOrEqual(context, (GreaterOrEqual) semanticObject); 
				return; 
			case MinifsmPackage.INT_ASSIGNMENT:
				sequence_IntAssignment(context, (IntAssignment) semanticObject); 
				return; 
			case MinifsmPackage.INT_VARIABLE_REF:
				sequence_IntVariableRef(context, (IntVariableRef) semanticObject); 
				return; 
			case MinifsmPackage.INTEGER:
				sequence_Integer(context, (fr.inria.diverse.melanger.melangedlang.minifsm.Integer) semanticObject); 
				return; 
			case MinifsmPackage.INTEGER_VAR:
				sequence_IntegerVar(context, (IntegerVar) semanticObject); 
				return; 
			case MinifsmPackage.LESS:
				sequence_Less(context, (Less) semanticObject); 
				return; 
			case MinifsmPackage.LESS_OR_EQUAL:
				sequence_LessOrEqual(context, (LessOrEqual) semanticObject); 
				return; 
			case MinifsmPackage.MINUS:
				sequence_PlusMinus(context, (Minus) semanticObject); 
				return; 
			case MinifsmPackage.MULTIPLY:
				sequence_MultDiv(context, (Multiply) semanticObject); 
				return; 
			case MinifsmPackage.NOT:
				if (rule == grammarAccess.getNotRule()) {
					sequence_Not(context, (Not) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanExpressionRule()
						|| rule == grammarAccess.getAndOrRule()
						|| action == grammarAccess.getAndOrAccess().getOrLeftAction_1_0_0()
						|| action == grammarAccess.getAndOrAccess().getAndLeftAction_1_1_0()
						|| rule == grammarAccess.getTermBoolRule()) {
					sequence_TermBool(context, (Not) semanticObject); 
					return; 
				}
				else break;
			case MinifsmPackage.OR:
				sequence_AndOr(context, (Or) semanticObject); 
				return; 
			case MinifsmPackage.PLUS:
				sequence_PlusMinus(context, (Plus) semanticObject); 
				return; 
			case MinifsmPackage.PRINT_STR:
				sequence_PrintStr(context, (PrintStr) semanticObject); 
				return; 
			case MinifsmPackage.PRINT_VAR:
				sequence_PrintVar(context, (PrintVar) semanticObject); 
				return; 
			case MinifsmPackage.STATE:
				sequence_State_Impl(context, (State) semanticObject); 
				return; 
			case MinifsmPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BooleanExpression returns And
	 *     AndOr returns And
	 *
	 * Constraint:
	 *     (left=AndOr_And_1_1_0 right=AndOr)
	 */
	protected void sequence_AndOr(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.BOOLEAN_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.BOOLEAN_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.BOOLEAN_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.BOOLEAN_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndOrAccess().getAndLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndOrAccess().getRightAndOrParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns Or
	 *     AndOr returns Or
	 *
	 * Constraint:
	 *     (left=AndOr_Or_1_0_0 right=AndOr)
	 */
	protected void sequence_AndOr(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.BOOLEAN_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.BOOLEAN_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.BOOLEAN_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.BOOLEAN_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndOrAccess().getOrLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndOrAccess().getRightAndOrParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (statement+=Statement statement+=Statement*)?
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BooleanAssignment
	 *     BooleanAssignment returns BooleanAssignment
	 *
	 * Constraint:
	 *     (variable=BooleanVariableRef value=BooleanExpression)
	 */
	protected void sequence_BooleanAssignment(ISerializationContext context, BooleanAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.BOOLEAN_ASSIGNMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.BOOLEAN_ASSIGNMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.BOOLEAN_ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.BOOLEAN_ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanAssignmentAccess().getVariableBooleanVariableRefParserRuleCall_2_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getBooleanAssignmentAccess().getValueBooleanExpressionParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns BooleanVar
	 *     BooleanVar returns BooleanVar
	 *
	 * Constraint:
	 *     (name=EString value=EBoolean?)
	 */
	protected void sequence_BooleanVar(ISerializationContext context, BooleanVar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns BooleanVariableRef
	 *     AndOr returns BooleanVariableRef
	 *     AndOr.Or_1_0_0 returns BooleanVariableRef
	 *     AndOr.And_1_1_0 returns BooleanVariableRef
	 *     TermBool returns BooleanVariableRef
	 *     BooleanVariableRef returns BooleanVariableRef
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_BooleanVariableRef(ISerializationContext context, BooleanVariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.VARIABLE_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.VARIABLE_REF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanVariableRefAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns Boolean
	 *     AndOr returns Boolean
	 *     AndOr.Or_1_0_0 returns Boolean
	 *     AndOr.And_1_1_0 returns Boolean
	 *     TermBool returns Boolean
	 *     Boolean returns Boolean
	 *
	 * Constraint:
	 *     value?='value'
	 */
	protected void sequence_Boolean(ISerializationContext context, fr.inria.diverse.melanger.melangedlang.minifsm.Boolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.BOOLEAN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.BOOLEAN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanAccess().getValueValueKeyword_0_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Context returns Context
	 *
	 * Constraint:
	 *     (variables+=Variable variables+=Variable*)?
	 */
	protected void sequence_Context(ISerializationContext context, Context semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns Equal
	 *     AndOr returns Equal
	 *     AndOr.Or_1_0_0 returns Equal
	 *     AndOr.And_1_1_0 returns Equal
	 *     TermBool returns Equal
	 *     IntComparison returns Equal
	 *     Equal returns Equal
	 *
	 * Constraint:
	 *     (left=IntExpression right=IntExpression)
	 */
	protected void sequence_Equal(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualAccess().getLeftIntExpressionParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualAccess().getRightIntExpressionParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FSM returns FSM
	 *
	 * Constraint:
	 *     ((states+=State states+=State*)? initialState=[State|EString] (transitions+=Transition transitions+=Transition*)? context=Context?)
	 */
	protected void sequence_FSM(ISerializationContext context, FSM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     State returns FinalState
	 *     FinalState returns FinalState
	 *
	 * Constraint:
	 *     (name=EString block=Block?)
	 */
	protected void sequence_FinalState(ISerializationContext context, FinalState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns GreaterOrEqual
	 *     AndOr returns GreaterOrEqual
	 *     AndOr.Or_1_0_0 returns GreaterOrEqual
	 *     AndOr.And_1_1_0 returns GreaterOrEqual
	 *     TermBool returns GreaterOrEqual
	 *     IntComparison returns GreaterOrEqual
	 *     GreaterOrEqual returns GreaterOrEqual
	 *
	 * Constraint:
	 *     (left=IntExpression right=IntExpression)
	 */
	protected void sequence_GreaterOrEqual(ISerializationContext context, GreaterOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreaterOrEqualAccess().getLeftIntExpressionParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGreaterOrEqualAccess().getRightIntExpressionParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns Greater
	 *     AndOr returns Greater
	 *     AndOr.Or_1_0_0 returns Greater
	 *     AndOr.And_1_1_0 returns Greater
	 *     TermBool returns Greater
	 *     IntComparison returns Greater
	 *     Greater returns Greater
	 *
	 * Constraint:
	 *     (left=IntExpression right=IntExpression)
	 */
	protected void sequence_Greater(ISerializationContext context, Greater semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreaterAccess().getLeftIntExpressionParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGreaterAccess().getRightIntExpressionParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IntAssignment
	 *     IntAssignment returns IntAssignment
	 *
	 * Constraint:
	 *     (variable=IntVariableRef value=IntExpression)
	 */
	protected void sequence_IntAssignment(ISerializationContext context, IntAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_ASSIGNMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_ASSIGNMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntAssignmentAccess().getVariableIntVariableRefParserRuleCall_2_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getIntAssignmentAccess().getValueIntExpressionParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns IntVariableRef
	 *     PlusMinus returns IntVariableRef
	 *     PlusMinus.Plus_1_0_0 returns IntVariableRef
	 *     PlusMinus.Minus_1_1_0 returns IntVariableRef
	 *     MultDiv returns IntVariableRef
	 *     MultDiv.Multiply_1_0_0 returns IntVariableRef
	 *     MultDiv.Divide_1_1_0 returns IntVariableRef
	 *     TermInt returns IntVariableRef
	 *     IntVariableRef returns IntVariableRef
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_IntVariableRef(ISerializationContext context, IntVariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.VARIABLE_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.VARIABLE_REF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntVariableRefAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns IntegerVar
	 *     IntegerVar returns IntegerVar
	 *
	 * Constraint:
	 *     (name=EString value=EInt?)
	 */
	protected void sequence_IntegerVar(ISerializationContext context, IntegerVar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns Integer
	 *     PlusMinus returns Integer
	 *     PlusMinus.Plus_1_0_0 returns Integer
	 *     PlusMinus.Minus_1_1_0 returns Integer
	 *     MultDiv returns Integer
	 *     MultDiv.Multiply_1_0_0 returns Integer
	 *     MultDiv.Divide_1_1_0 returns Integer
	 *     TermInt returns Integer
	 *     Integer returns Integer
	 *
	 * Constraint:
	 *     value=EInt
	 */
	protected void sequence_Integer(ISerializationContext context, fr.inria.diverse.melanger.melangedlang.minifsm.Integer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INTEGER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INTEGER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerAccess().getValueEIntParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns LessOrEqual
	 *     AndOr returns LessOrEqual
	 *     AndOr.Or_1_0_0 returns LessOrEqual
	 *     AndOr.And_1_1_0 returns LessOrEqual
	 *     TermBool returns LessOrEqual
	 *     IntComparison returns LessOrEqual
	 *     LessOrEqual returns LessOrEqual
	 *
	 * Constraint:
	 *     (left=IntExpression right=IntExpression)
	 */
	protected void sequence_LessOrEqual(ISerializationContext context, LessOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLessOrEqualAccess().getLeftIntExpressionParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLessOrEqualAccess().getRightIntExpressionParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns Less
	 *     AndOr returns Less
	 *     AndOr.Or_1_0_0 returns Less
	 *     AndOr.And_1_1_0 returns Less
	 *     TermBool returns Less
	 *     IntComparison returns Less
	 *     Less returns Less
	 *
	 * Constraint:
	 *     (left=IntExpression right=IntExpression)
	 */
	protected void sequence_Less(ISerializationContext context, Less semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_COMPARISON__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLessAccess().getLeftIntExpressionParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLessAccess().getRightIntExpressionParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns Divide
	 *     PlusMinus returns Divide
	 *     PlusMinus.Plus_1_0_0 returns Divide
	 *     PlusMinus.Minus_1_1_0 returns Divide
	 *     MultDiv returns Divide
	 *     MultDiv.Multiply_1_0_0 returns Divide
	 *     MultDiv.Divide_1_1_0 returns Divide
	 *     TermInt returns Divide
	 *
	 * Constraint:
	 *     (left=MultDiv_Divide_1_1_0 right=TermInt)
	 */
	protected void sequence_MultDiv(ISerializationContext context, Divide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultDivAccess().getDivideLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultDivAccess().getRightTermIntParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns Multiply
	 *     PlusMinus returns Multiply
	 *     PlusMinus.Plus_1_0_0 returns Multiply
	 *     PlusMinus.Minus_1_1_0 returns Multiply
	 *     MultDiv returns Multiply
	 *     MultDiv.Multiply_1_0_0 returns Multiply
	 *     MultDiv.Divide_1_1_0 returns Multiply
	 *     TermInt returns Multiply
	 *
	 * Constraint:
	 *     (left=MultDiv_Multiply_1_0_0 right=TermInt)
	 */
	protected void sequence_MultDiv(ISerializationContext context, Multiply semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultDivAccess().getMultiplyLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultDivAccess().getRightTermIntParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Not returns Not
	 *
	 * Constraint:
	 *     expression=AndOr
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotAccess().getExpressionAndOrParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns Minus
	 *     PlusMinus returns Minus
	 *     PlusMinus.Plus_1_0_0 returns Minus
	 *     PlusMinus.Minus_1_1_0 returns Minus
	 *     MultDiv returns Minus
	 *     MultDiv.Multiply_1_0_0 returns Minus
	 *     MultDiv.Divide_1_1_0 returns Minus
	 *     TermInt returns Minus
	 *
	 * Constraint:
	 *     (left=PlusMinus_Minus_1_1_0 right=MultDiv)
	 */
	protected void sequence_PlusMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusMinusAccess().getMinusLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusMinusAccess().getRightMultDivParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntExpression returns Plus
	 *     PlusMinus returns Plus
	 *     PlusMinus.Plus_1_0_0 returns Plus
	 *     PlusMinus.Minus_1_1_0 returns Plus
	 *     MultDiv returns Plus
	 *     MultDiv.Multiply_1_0_0 returns Plus
	 *     MultDiv.Divide_1_1_0 returns Plus
	 *     TermInt returns Plus
	 *
	 * Constraint:
	 *     (left=PlusMinus_Plus_1_0_0 right=MultDiv)
	 */
	protected void sequence_PlusMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.INT_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.INT_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusMinusAccess().getPlusLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusMinusAccess().getRightMultDivParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PrintStr
	 *     PrintStr returns PrintStr
	 *
	 * Constraint:
	 *     value=EString
	 */
	protected void sequence_PrintStr(ISerializationContext context, PrintStr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.PRINT_STR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.PRINT_STR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintStrAccess().getValueEStringParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PrintVar
	 *     PrintVar returns PrintVar
	 *
	 * Constraint:
	 *     value=EString
	 */
	protected void sequence_PrintVar(ISerializationContext context, PrintVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.PRINT_VAR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.PRINT_VAR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintVarAccess().getValueEStringParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     State returns State
	 *     State_Impl returns State
	 *
	 * Constraint:
	 *     (name=EString block=Block?)
	 */
	protected void sequence_State_Impl(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns Not
	 *     AndOr returns Not
	 *     AndOr.Or_1_0_0 returns Not
	 *     AndOr.And_1_1_0 returns Not
	 *     TermBool returns Not
	 *
	 * Constraint:
	 *     expression=TermBool
	 */
	protected void sequence_TermBool(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinifsmPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinifsmPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTermBoolAccess().getExpressionTermBoolParserRuleCall_3_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Transition returns Transition
	 *
	 * Constraint:
	 *     (input=[State|EString] output=[State|EString] expression=BooleanExpression?)
	 */
	protected void sequence_Transition(ISerializationContext context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
