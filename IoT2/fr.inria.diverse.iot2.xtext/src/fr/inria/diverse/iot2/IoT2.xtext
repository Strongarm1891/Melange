// automatically generated by Xtext
grammar fr.inria.diverse.iot2.IoT2 with org.eclipse.xtext.common.Terminals

import "http://iot2/" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

System:
	'system' name=ID '{'
		(components+=HWComponent (components+=HWComponent)*)?
		(boards+=Board (boards+=Board)*)?
		(sketch=Sketch)?
	'}';

Contained returns Contained:
	OperationDef;

HWComponent:
	Sensor | Actuator;

Sensor:
	'sensor' name = ID ('{'
		('provides' services += OperationDef)*
	'}')?
;

Actuator:
	'actuator' name = ID ('{'
		('provides' services += OperationDef)*
	'}')?
;

Board returns Board:
	{Board}
	'board' name=ID '[' type = BoardType ']'
	('{'
		('provides' components+=[HWComponent|ID])*
	'}')?;

enum BoardType:
	RaspberryPi = 'RaspberryPi' | Arduino = 'Arduino' | BeagleBoard = 'BeagleBoard'
;

Sketch returns Sketch:
	{Sketch}
	'sketch'
	'{'
		activity=Activity
	'}';

EBoolean returns ecore::EBoolean:
	'true' | 'false';

OperationDef returns OperationDef:
	{OperationDef}
	'operation'
	name=ID
	'(' ( parameters += ParameterDef (',' parameters += ParameterDef)* )? ')'
	'{'
		lua=Block
	'}';

ParameterDef:
	direction=param_attribute (containedType=PrimitiveDef)
	identifier=ID
;

enum param_attribute returns ParameterMode:
	PARAM_IN='in'
	|	PARAM_OUT='out'
	|	PARAM_INOUT='inout'
;

PrimitiveDef
	:	integer_type
	|	floating_pt_type
	|	charstr_type
	|	other_type
	;

//---------------------------
// BASE TYPES
//---------------------------


floating_pt_type returns PrimitiveDef
	:	kind = float_type
	|	kind = double_type
	|	kind = longdouble_type
	;

enum float_type returns PrimitiveKind
	:	PK_FLOAT = 'float'
	;

enum double_type returns PrimitiveKind
	:	PK_DOUBLE = 'double'
	;

longdouble_type returns PrimitiveKind
	:	'long' 'double'
	;


integer_type returns PrimitiveDef
	:	kind = short_type
	|	kind = long_type
	|	kind = longlong_type
	|	kind = ushort_type
	|	kind = ulong_type
	|	kind = ulonglong_type
	;

enum short_type returns PrimitiveKind
	:	PK_SHORT = 'short'
	;

enum long_type returns PrimitiveKind
	:	PK_LONG = 'long'
	;

longlong_type returns PrimitiveKind
	:	'long' 'long'
	;

ushort_type returns PrimitiveKind
	:	'unsigned' 'short'
	;

ulong_type returns PrimitiveKind
	:	'unsigned' 'long'
	;

ulonglong_type returns PrimitiveKind
	:	'unsigned' 'long' 'long'
	;



charstr_type returns PrimitiveDef
	:	kind = char_type
	|	kind = wide_char_type
	|	kind = string_type
	|	kind = wide_string_type
	;

enum char_type returns PrimitiveKind
	:	PK_CHAR = 'char'
	;

enum wide_char_type returns PrimitiveKind
	:	PK_WCHAR = 'wchar'
	;

enum string_type returns PrimitiveKind
	:	PK_STRING = 'string'
	;

enum wide_string_type returns PrimitiveKind
	:	PK_WSTRING = 'wstring'
	;


other_type returns PrimitiveDef
	:	kind = boolean_type
	|	kind = octet_type
	|	kind = any_type
	;
	
enum boolean_type returns PrimitiveKind
	:	PK_BOOLEAN = 'boolean'
	;

enum octet_type returns PrimitiveKind
	:	PK_OCTET = 'octet'
	;

enum any_type returns PrimitiveKind
	:	PK_ANY = 'any'
	;


enum object_type returns PrimitiveKind
	:	PK_OBJREF = 'Object'
	;

enum void_type returns PrimitiveKind
	:	PK_VOID = 'void'
	;

Chunk:
	Block
;
 
Block:
    {Block}
    (statements+=Statement (';')? )*
    ( returnValue=LastStatement (';')? )?;
 
// ****************************************************
// LAST STATEMENT
// ****************************************************
LastStatement: 
    LastStatement_Return | LastStatement_Break;
 
// The return statement is used to return values from a function or a chunk
LastStatement_Return: 
    'return' {LastStatement_ReturnWithValue} (returnValues+=Expression (',' returnValues+=Expression)*)?;
 
// The break statement is used to terminate the execution of a while, repeat, or for loop, skipping to the next statement after the loop
LastStatement_Break: 
    'break' {LastStatement_Break};
 
// ****************************************************
// STATEMENT
// ****************************************************
Statement:
    Statement_Block |
    Statement_While |
    Statement_Repeat |
    Statement_If_Then_Else |
    Statement_For_Numeric |
    Statement_For_Generic |
    Statement_GlobalFunction_Declaration |
    Statement_LocalFunction_Declaration |
    Statement_Local_Variable_Declaration |
    Statement_FunctioncallOrAssignment;
 
// A block can be explicitly delimited to produce a single statement. "do ... end"
Statement_Block: 
    'do' block=Block 'end';
 
// Control structure. "while ... do ... end"
Statement_While: 
    'while' expression=Expression 'do' block=Block 'end';
 
// Control structure. "repeat ... until ..."
Statement_Repeat: 
    'repeat' block=Block 'until' expression=Expression;
 
// Control structure. "if ... then ... elseif ... elseif ... else ... end"
Statement_If_Then_Else: 
    'if' ifExpression=Expression 'then' ifBlock=Block (elseIf+=Statement_If_Then_Else_ElseIfPart)* ('else' elseBlock=Block)? 'end';
Statement_If_Then_Else_ElseIfPart:
    'elseif' elseifExpression=Expression 'then' elseifBlock=Block;
 
// The numeric for loop repeats a block of code while a control variable runs through an arithmetic progression "for ...=..., ... [,...] do ... end"
Statement_For_Numeric: 
    'for' iteratorName=ID '=' startExpr=Expression "," untilExpr=Expression ("," stepExpr=Expression)? 'do' block=Block 'end';
 
// The generic for statement works over functions, called iterators. On each iteration, the iterator function is called to produce a new value, stopping when this new value is nil "for ... in ... do ... end"
Statement_For_Generic: 
    'for' names+=ID (',' names+=ID)* 'in' expressions+=Expression (',' expressions+=Expression)* 'do' block=Block 'end';
 
Statement_GlobalFunction_Declaration:
    'function' prefix+=ID ('.' prefix+=ID)* (':' functionName=ID)? function=Function 'end';
 
Statement_LocalFunction_Declaration:
    'local' 'function' functionName=ID function=Function 'end';
 
// Local variables can be declared anywhere inside a block. The declaration can include an initial assignment "local ... [= ...]"
Statement_Local_Variable_Declaration: 
    'local' variableNames+=ID (',' variableNames+=ID)* ('=' initialValue+=Expression (',' initialValue+=Expression)*)?;
 
Statement_FunctioncallOrAssignment:
    Expression_AccessMemberOrArrayElement (
        // Assignment
        ({Statement_Assignment.variable+=current} (=> ',' variable+=Expression_AccessMemberOrArrayElement)* '=' values+=Expression (',' values+=Expression)*) |
 
        // Call of a member function
        (':' {Statement_CallMemberFunction.object=current} memberFunctionName=ID arguments=Functioncall_Arguments ) |
 
        // Call of a function pointer
        ({Statement_CallFunction.object=current} arguments=Functioncall_Arguments)
    );
 
// ****************************************************
// EXPRESSIONS
// ****************************************************
// Delegate to the priority chain of operators by calling the rule for the lowest priority operator
Expression: 
    Expression_Or;
 
// Or: left associative, priority 0
Expression_Or returns Expression: 
    Expression_And ('or' {Expression_Or.left=current} right=Expression_And)*;
 
// And: left associative, priority 1
Expression_And returns Expression: 
    Expression_Compare ('and' {Expression_And.left=current} right=Expression_Compare)*;
 
// Comparisons: left associative, priority 2
Expression_Compare returns Expression: 
    Expression_Concatenation (
        ('>'  {Expression_Larger.left=current} right=Expression_Concatenation) |
        ('>=' {Expression_Larger_Equal.left=current} right=Expression_Concatenation) |
        ('<'  {Expression_Smaller.left=current} right=Expression_Concatenation) |
        ('<=' {Expression_Smaller_Equal.left=current} right=Expression_Concatenation) |
        ('==' {Expression_Equal.left=current} right=Expression_Concatenation) |
        ('~=' {Expression_Not_Equal.left=current} right=Expression_Concatenation)
    )*;
 
// Concatenation: right associative, priority 3
Expression_Concatenation returns Expression: 
    Expression_PlusMinus ('..' {Expression_Concatenation.left=current} right=Expression_Concatenation)?;
 
// addition/subtraction: left associative, priority 4
Expression_PlusMinus returns Expression: 
    Expression_MultiplicationDivisionModulo (
        ('+'  {Expression_Plus.left=current} right=Expression_MultiplicationDivisionModulo) |
        ('-'  {Expression_Minus.left=current} right=Expression_MultiplicationDivisionModulo)
    )*;
 
// multiplication/division, left associative, priority 5
Expression_MultiplicationDivisionModulo returns Expression:
    Expression_Unary (
        ('*'  {Expression_Multiplication.left=current} right=Expression_Unary) |
        ('/'  {Expression_Division.left=current} right=Expression_Unary) |
        ('%'  {Expression_Modulo.left=current} right=Expression_Unary)
    )*;
 
// Unary operators: right associative, priority 6
Expression_Unary returns Expression: 
    Expression_Exponentiation |
    ('not' {Expression_Negate} exp=Expression_Unary) |
    ('#'   {Expression_Length} exp=Expression_Unary) |
    ('-'   {Expression_Invert} exp=Expression_Unary);
 
// exponentiation: right associative, priority 7
Expression_Exponentiation returns Expression: 
    Expression_Terminal
    ( '^' {Expression_Exponentiation.left=current} right=Expression_Exponentiation )?;
 
Expression_Terminal returns Expression:
    Expression_Nil |
    Expression_True |
    Expression_False |
    Expression_Number |
    Expression_VarArgs |
    Expression_String |
    Expression_Function |
    Expression_TableConstructor |
    Expression_Functioncall;
 
Expression_Nil:
    'nil' {Expression_Nil};
Expression_True:
    'true' {Expression_True};
Expression_False:
    'false' {Expression_False};
Expression_Number:
    value=Double;
Expression_VarArgs:
    '...' {Expression_VarArgs};
Expression_String:
    value=STRING;
Expression_Function:
    'function' function=Function 'end';
Expression_TableConstructor:
    '{' {Expression_TableConstructor} (fields+=Field ((','|';') fields+=Field)* (','|';')? )? '}';
 
// Function calls, left associative, single call only, priority 9
Expression_Functioncall returns Expression: 
    Expression_AccessMemberOrArrayElement (
        // Member-Funktionsaufruf
        (=> ':' {Expression_CallMemberFunction.object=current} memberFunctionName=ID arguments=Functioncall_Arguments) |
 
        // Aufruf eines Funktionspointer:
        ({Expression_CallFunction.object=current} arguments=Functioncall_Arguments)
    )?;
 
// Access a member or array element, left associative, chaining possible, priority 10
Expression_AccessMemberOrArrayElement returns Expression: 
    Expression_VariableName (
        // An expression accessing an element in a variable array
        ('[' {Expression_AccessArray.array=current} index=Expression ']') |
 
        // Access a member variable using multiple parts separated by "."
        ('.' {Expression_AccessMember.object=current} memberName=ID)
    )*;
 
// access a variable, terminal expression, priority 11
// Delegate to top of expression rule chain for bracketed expressions
Expression_VariableName returns Expression: 
    ('(' Expression ')') |
    ({Expression_VariableName} variable=ID);
 
 
// ****************************************************
// FUNCTIONS
// ****************************************************
Function:
    '(' (parameters+=ID (',' parameters+=ID)* ','?)? (varArgs?='...')? ')' body=Block;
 
// Some syntactic sugar: strings and field can be passed as parameters without bracket
Functioncall_Arguments: 
    {Functioncall_Arguments}
    (
        ('(' (arguments+=Expression (',' arguments+=Expression)*)? ')' ) |
        (arguments+=Expression_TableConstructor) |
        (arguments+=Expression_String)
    );
 
// ****************************************************
// TABLES/FIELDS
// ****************************************************
Field:
    Field_AddEntryToTable_Brackets |
    Field_AddEntryToTable |
    Field_AppendEntryToTable;
 
// Each field of the form "[exp1] = exp2" adds to the new table an entry with key exp1 and value exp2
Field_AddEntryToTable_Brackets: 
    '[' indexExpression=Expression ']' '=' value=Expression;
 
// A field of the form "name = exp" is equivalent to ["name"] = exp
Field_AddEntryToTable: 
    key=ID '=' value=Expression;
 
// fields of the form "exp" are equivalent to [i] = exp
Field_AppendEntryToTable: 
    value=Expression;
 
// ****************************************************
// TERMINALS
// ****************************************************
// Identifiers can be any string of letters, digits, and underscores, but mustn't begin with a digit.

Activity returns Activity:
	{Activity}
	'activity'
	name=ID ('(' inputs+=Variable ( "," inputs+=Variable)* ')' )?
	'{'
		(locals+=Variable ( "," locals+=Variable)* )?
		('nodes' '{' nodes+=ActivityNode ( "," nodes+=ActivityNode)* '}' )?
		('edges' '{' edges+=ActivityEdge ( "," edges+=ActivityEdge)* '}' )?

	'}';

ActivityNode returns ActivityNode:
	OpaqueAction | InitialNode | ActivityFinalNode | ForkNode | JoinNode | MergeNode | DecisionNode;

ActivityEdge returns ActivityEdge:
	ControlFlow;

Variable returns Variable:
	IntegerVariable | BooleanVariable;

Value returns Value:
	BooleanValue | IntegerValue;

OpaqueAction returns OpaqueAction:
	{OpaqueAction}
	'action'
	name=ID
		('comp' '{' expressions+=ActivityExpression ( "," expressions+=ActivityExpression)* '}' )?
		('in' '(' incoming+=[ActivityEdge] ( "," incoming+=[ActivityEdge])* ')' )?
		('out' '(' outgoing+=[ActivityEdge] ( "," outgoing+=[ActivityEdge])* ')' )?
		('service' service = [OperationDef])?
		;

ActivityExpression returns Expression:
	IntegerCalculationExpression | IntegerComparisonExpression | BooleanUnaryExpression | BooleanBinaryExpression;

enum IntegerCalculationOperator returns IntegerCalculationOperator:
				ADD = '+' | SUBRACT = '-';

enum IntegerComparisonOperator returns IntegerComparisonOperator:
				SMALLER = '<' | SMALLER_EQUALS = '<=' | EQUALS = '==' | GREATER_EQUALS = '>=' | GREATER = '>';

enum BooleanUnaryOperator returns BooleanUnaryOperator:
				NOT = '!';

enum BooleanBinaryOperator returns BooleanBinaryOperator:
				AND = '&' | OR = '|';

IntegerCalculationExpression returns IntegerCalculationExpression:
		assignee=[IntegerVariable] '='
		operand1=[IntegerVariable]
		operator=IntegerCalculationOperator
		operand2=[IntegerVariable];

IntegerComparisonExpression returns IntegerComparisonExpression:
		assignee=[BooleanVariable] '='
		operand1=[IntegerVariable]
		operator=IntegerComparisonOperator
		operand2=[IntegerVariable];

BooleanUnaryExpression returns BooleanUnaryExpression:
		assignee=[BooleanVariable] '='
		operator=BooleanUnaryOperator
		operand=[BooleanVariable];

BooleanBinaryExpression returns BooleanBinaryExpression:
		assignee=[BooleanVariable] '='
		operand1=[BooleanVariable]
		operator=BooleanBinaryOperator
		operand2=[BooleanVariable];

InitialNode returns InitialNode:
	{InitialNode}
	'initial'
	name=ID
		('out' '(' outgoing+=[ActivityEdge] ( "," outgoing+=[ActivityEdge])* ')' )
	;

ActivityFinalNode returns ActivityFinalNode:
	{ActivityFinalNode}
	'final'
	name=ID
		('in' '(' incoming+=[ActivityEdge] ( "," incoming+=[ActivityEdge])* ')' )
	;

ForkNode returns ForkNode:
	{ForkNode}
	'fork'
	name=ID
		('in' '(' incoming+=[ActivityEdge] ')' )
		('out' '(' outgoing+=[ActivityEdge] ( "," outgoing+=[ActivityEdge])* ')' )?
	;

JoinNode returns JoinNode:
	{JoinNode}
	'join'
	name=ID
		('in' '(' incoming+=[ActivityEdge] ( "," incoming+=[ActivityEdge])* ')' )?
		('out' '(' outgoing+=[ActivityEdge] ')' )
	;

MergeNode returns MergeNode:
	{MergeNode}
	'merge'
	name=ID
		('in' '(' incoming+=[ActivityEdge] ( "," incoming+=[ActivityEdge])* ')' )?
		('out' '(' outgoing+=[ActivityEdge] ')' )
	;

DecisionNode returns DecisionNode:
	{DecisionNode}
	'decision'
	name=ID
		('in' '(' incoming+=[ActivityEdge] ')' )
		('out' '(' outgoing+=[ActivityEdge] ( "," outgoing+=[ActivityEdge])* ')' )?
	;

IntegerVariable returns IntegerVariable:
	{IntegerVariable}
	'int'
	name=ID
		('=' initialValue=IntegerValue)?;
	
BooleanVariable returns BooleanVariable:
	{BooleanVariable}
	'bool'
	name=ID
		('=' initialValue=BooleanValue)?;

BooleanValue returns BooleanValue:
	value=EBoolean;

IntegerValue returns IntegerValue:
	value=INT;

ControlFlow returns ControlFlow:
	'flow'
	name=ID
		'from' source=[ActivityNode]
		'to' target=[ActivityNode]
		('[' guard=[BooleanVariable] ']')?;

Double returns ecore::EDouble:
	(INT) ('.' INT)?
;
